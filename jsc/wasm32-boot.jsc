var vm = new Wasm32VM();
var system = new Wasm32System();
var module;

if (remote) {
    caches.open("v3").then((cache) => {
        var req = new Request(path);

        return cache.match(req).then((response) => {
            if (response === undefined)
                return fetch(path);

            return response;
        }).then(response => {
            cache.put(path, response.clone());

            if (response.ok)
                return response.arrayBuffer();

            return Promise.reject(response);
        });
    }).then((ab) => {
        console.log("launching");
        var [root, cwd, stdin, stdout, stderr] = remote_process(ab);
        var process = new Wasm32Process(system);

        (new ThinThinFD(process, 0)).connectPort(stdin);
        (new ThinThinFD(process, 1)).connectPort(stdout);
        (new ThinThinFD(process, 2)).connectPort(stderr);
        console.log("launched");
    }).catch(e => {
        console.log("e2:" + e);
    })
} else if (typeof os !== "undefined") {
    module = new Wasm32Module(os.file.readFile(path, "binary"));

    system.instantiate(module, vm, args, environment_variables()).then(() => {
        try {
            run = () => {
                try {
                    system.threads[0].step();
                    if (!system.threads[0].stopped())
                        Promise.resolve().then(run);
                } catch (e) {
                    console.log("another exception");
                    console.log(e);
                    console.log(e.stack);
                }
            };
            run();
        } catch (e) {
            console.log("exception");
            console.log(e);
            console.log(e.stack);
        }
    }).catch((e) => {
        console.log("caught");
        console.log(e);
    });
} else if (typeof fetch !== "undefined") {
    caches.open("v3").then((cache) => {
        var req = new Request(path);

        return cache.match(req).then((response) => {
            if (response === undefined)
                return fetch(path);

            return response;
        }).then(response => {
            cache.put(path, response.clone());

            if (response.ok)
                return response.arrayBuffer();

            return Promise.reject(response);
        });
    }).then((ab) => {
        module = new Wasm32Module(ab);

        return system.instantiate(module, vm, args, []);
    }).then(() => {
        try {
            run = () => {
                try {
                    system.threads[0].step();
                    if (!system.threads[0].stopped())
                        Promise.resolve().then(run);
                } catch (e) {
                    console.log("another exception");
                    console.log(e);
                    console.log(e.stack);
                }
            };
            run();
        } catch (e) {
            console.log("exception");
            console.log(e);
            console.log(e.stack);
        }
    }).catch((e) => {
        console.log("caught");
        console.log(e);
        console.log(e.stack);
    });
}

