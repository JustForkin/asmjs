var vm = new Wasm32VM();
var module = new Wasm32Module(os.file.readFile(path, "binary"));
var system = new Wasm32System();

function abtoascii(ab)
{
    let h8 = new Uint8Array(ab);
    let s = "";

    for (var i = 0; i < h8.byteLength; i++) {
        let c = h8[i];

        if (c >= 0x80)
            throw "non-ASCII byte";

        s += String.fromCharCode(h8[i]);
    }

    return s;
}

var mystep;

system.instantiate(module, vm, args, environment_variables()).then(() => {
    var cs = WebAssembly.Module.customSections(module.module, "dyninfo");
    for (let c of cs) {
        let s = abtoascii(c);
        eval(s);
    }
    try {
        var first = true;
        var dpc = -1;
        var pc0 = 0xa;
        /* The 0x10 offset is for... err... making things work. Somehow.
         * Possibly a remnant of the incomplete 64-bitification. */
        var sp = system.threads[0].%{tp1[&threadpage::sp]} + 0x10;
        var rpc = 0;
        mystep = () => {
            console.log("calling pc0 " + pc0 + " dpc " + dpc + " rpc " + rpc + " sp " + sp);
                console.log("pc0 " + pc0 + " dpc " + dpc + " real dpc " + system.threads[0].HEAPU32[sp+16>>2] + " sp " + sp);
            var ret;
            if (first) {
                console.log("first");
                ret = system.threads[0].exports._start(dpc, sp, 0, 0, rpc, pc0);
                first = false;
            } else {
                try {
                    ret = system.threads[0].indcall(dpc, sp, 0, 0, rpc, pc0);
                } catch (e) {
                    console.log("exception");
                    console.log(e);
                    console.log(e.stack);
                }
            }
            console.log("called: " + ret);

            if (ret & 3) {
                sp = ret;
                sp &= -4;
                pc0 = system.threads[0].HEAPU32[sp+8>>2];
                dpc = 0;
                console.log("pc0 " + pc0 + " dpc " + dpc + " real dpc " + system.threads[0].HEAPU32[sp+16>>2] + " sp " + sp);
                //console.log("pc0 " + pc0 + " dpc " + dpc);
                //sp += 16;
            } else {
                sp = ret; //system.threads[0].HEAPU32[ret+16>>2];
                for (var off = -192; off < 192; off += 4)
                    console.log("off " + off + " p " + (sp+off) + " v " + system.threads[0].HEAPU32[sp+off>>2]);
                sp = system.threads[0].HEAPU32[sp>>2];
                pc0 = system.threads[0].HEAPU32[sp+8>>2];
                dpc = 0; //system.threads[0].HEAPU32[sp+28>>2];
                console.log("pc0 " + pc0 + " dpc " + dpc + " real dpc " + system.threads[0].HEAPU32[sp+16>>2] + " sp " + sp);
                //sp += 16;
            }
            Promise.resolve().then(mystep);
        };
        mystep();
    } catch (e) {
        console.log("exception");
        console.log(e);
        console.log(e.stack);
    }
}).catch((e) => {
    console.log("caught");
    console.log(e);
});
