var args = ["./fannkuch", "10"];
var env = [];

var system = new Wasm32System();

onmessage = event => {
    console.log("message " + event.data);
    var [frozen_process, frozen_vm, frozen_sp,
         stdin_port, stdout_port, stderr_port] = event.data;

    var process = new Wasm32Process(system);
    var thread = new Wasm32Thread(process, undefined, 8192);

    thread.extcallRet[frozen_sp] = 0;

    var vm = thread.vm;
    var p = Promise.resolve();
    for (var frozen_module1 of frozen_process.modules) {
        let frozen_module = frozen_module1;
        let module = new Wasm32Module(process, frozen_module.bytes);
        p = p.then(() => {
            return module.reload_at(thread, vm, frozen_module);
        });
    }
    for (var frozen_fd of frozen_process.fds) {
        var fd = new ThinThinFD(process, frozen_fd.fdno);
    }
    var heap = new Uint8Array(frozen_vm.memory);
    console.log("restored vm");

    p.then(() => {
    console.log("restoring memory")
    try {
    for (var i = 0; i < 1024 * 1024 * 1024; i++)
        vm.HEAPU8[i] = heap[i];
    } catch (e) {
        console.log(e);
    }
    console.log("restoring memory")
    vm.table_length = frozen_vm.table_length;
        for (var y in frozen_vm.table) {
        vm.table.set(y, vm.table.get(frozen_vm.table[y]));
    }
    thread.vm = vm;
    thread.first = false;
    thread.entry = 9;
    system.runqueue.push(thread);
    console.log("started");
    postMessage(undefined);
    try {
        var rr0 = new RRPort(stdin_port);
        var rr1 = new RRPort(stdout_port);
        var rr2 = new RRPort(stderr_port);

        var pipe0 = new ThinThinHalf();
        var pipe1 = new ThinThinHalf();
        var pipe2 = new ThinThinHalf();

        new RRPortHalf(pipe0, rr0, true);
        new RRPortHalf(pipe1, rr1, true);
        new RRPortHalf(pipe2, rr2, true);

        new ThinThinHalfFD(process, pipe0, 0);
        new ThinThinHalfFD(process, pipe1, 1);
        new ThinThinHalfFD(process, pipe2, 2);

        rr0.port.start();
        rr1.port.start();
        rr2.port.start();
        run = () => {
            console.log("running");
            try {
                system.threads[0].step();
                if (!system.threads[0].stopped())
                    Promise.resolve().then(run);
            } catch (e) {
                console.log("another exception");
                console.log(e);
                console.log(e.stack);
            }
        };
        run();
    } catch (e) {
        console.log("exception");
        console.log(e);
        console.log(e.stack);
    }
    });
};
